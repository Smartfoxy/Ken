<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ken_Ken</title>
    <style>
        :root {
            --result-color: black;
            --union-index: 2;
        }

        .container {
            width: 800px;
            height: 800px;
            background-color: rgb(224, 224, 224);
            margin: 50px auto;
            display: flex;
            flex-flow: column wrap;
            align-items: center;
            justify-content: space-evenly;
        }
        .table {
            border: 1px solid blue;
            padding: 15px;
            
        }
        .cell {
            border: 1px solid gray;
            height: 45px;
            width: 45px;
            text-align: center;
            position: relative;
            font-size: 28px;
            color: green;
        }
        .cell::after {
            content: attr(data-oper);
            position: absolute;
            left: 0;
            top: 0;
            color: var( --result-color, black);
            font-size: 14px;
        }
        .cell.wrongResult::after {
            color: red;
        }
        table {
            border-collapse: collapse;
            border: 3px solid black;  
        }
        .cell:focus{
            background-color: #80808082;
            outline: none;
        }
        /*.cellInput {
            box-sizing: border-box;
            background-color: lightblue;
            padding: 5px;
            border: 0;
            width: 50px;
            height: 50px;
            font-size: 26px;
            color: green;
            text-align: center;
            outline: none;
            cursor: default;
           /*caret-color: transparent;*/
        /*}
        input::-webkit-outer-spin-button,
            input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .cellInput:focus{
            background-color: aqua;
        }*/
        .red {
            color: red;
        }
        .bottom {
            border-bottom: 3px solid black;
        }
        .right {
            border-right: 3px solid black;    
        }
        ._0 {
            background-color: red;
        }
        ._1 {
            background-color: yellow;
        }
        ._2 {
            background-color: green;
        }
        ._3 {
            background-color: blue;
        }
        ._4 {
            background-color: orange;
        }
        ._5 {
            background-color: lawngreen;
        }
        ._6 {
            background-color: lightcoral;
        }
        ._7 {
            background-color: rebeccapurple;
        }
        ._8 {
            background-color: tan;
        }
        ._9 {
            background-color: lightgray;
        }
        ._10 {
            background-color: brown;
        }
        ._11 {
            background-color: fuchsia;
        }
        ._12 {
            background-color: darkcyan;
        }
        ._13 {
            background-color: red;
        }
        ._14 {
            background-color: yellowgreen;
        }
        ._15 {
            background-color: aqua;
        }
        ._16 {
            background-color: yellow;
        }
        ._17 {
            background-color: green;
        }
        ._18 {
            background-color: blue;
        }
        ._19 {
            background-color: orange;
        }
        ._20 {
            background-color: lawngreen;
        }
        ._21 {
            background-color: lightcoral;
        }
        ._22 {
            background-color: rebeccapurple;
        }
        ._23 {
            background-color: tan;
        }
        ._24 {
            background-color: lightgray;
        }
        
        
    </style>
</head>
<body>
    <div class="container">
        <form name="kenOptions">
            <label for="size">Размер:</label>
            <select name="size" id="size">
                <option value="4">4*4</option>
                <option value="5">5*5</option>
                <option value="6">6*6</option>
                <option value="7">7*7</option>
                <option value="8">8*8</option>
                <option value="9">9*9</option>
            </select>
            <button type="button" class="btn" name="new">Новый</button>
            <button type="button" class="btn" name="resolve">Решить</button>
        </form>
        <div class="table">
            <table></table>
        </div>
        
    </div>

    <script>
        "use strict"

        
        
        //отменить ход

        //если все правильно - помигать
        //правильно - исходя из повторов и результата операции и когда нет пустіх ячеек
        //может нужно кей ап использовать чтобы Ура было после того как цифра нарисовалась
        
        //соседние проверять- ели у них нет соседей то брать их в юнион
        //ходить назад, разніе фигуры

        //заполнять т.к. Рома описал
        
        class Cell {
            constructor(row, col) {
                this.row = row;
                this.col = col;
                this.fill = false;
                this.union = false;
                this.border = '';
            }
            fillNum(num) {
                this.num = num;
                this.fill = true;
            }
            unionCells(unionIndex) {
                this.unionIndex = unionIndex;
                this.union = true;
            }
            addBorder(type) {
                this.border += type + ' ';
            }
            addOperatorAttr(oper_res) {
                this.oper_resAttr = oper_res;
            }
        }

        class Union {
            constructor(index) {
                this.index = index;
                this.cellsInUnion = [];
                this.oper = '';
                this.result = '';
            }
            addCellToUnion(cell) {
                this.cellsInUnion.push(cell);
            }
            setSortRowsNumbers(rows) {
                this.sortRowsNums = rows;
            }
            setOperator(oper) {
                this.oper = oper;
            }
            setResult(result) {
                this.result = result;
            }
            setOperatorAndResult() {
                this.oper_result = this.result + this.oper;
            }
        }

        const $kenOptionsForm = document.forms.kenOptions;

        
        let indexOfUnion = 0;
        let arrOfUnions = [];
        let num = 3;
        let tab = 1;
        process(num);
       


        $kenOptionsForm.size.addEventListener('change', function(ev) {
            ev.preventDefault();
            num = $kenOptionsForm.size.value;
            process(num);   
        })

        $kenOptionsForm.new.addEventListener('click', function(ev) {
            ev.preventDefault();
            num = +$kenOptionsForm.size.value;
            process(num);    
        })
        

        function process(num) {
            let kenArr = createKen(num);
            fillKen(kenArr);
            console.log(kenArr);
            unionCells(kenArr);
            console.log(arrOfUnions);

            arrOfUnions.forEach(union => {
                drawBordersOfUnion(union);
                setOperatorAndResult(union);
                selectCellinUnionForOperAttr(union);
            })

            drawTableForResolve(kenArr);
            $kenOptionsForm.resolve.addEventListener('click', function(ev) {
                ev.preventDefault();
                drawResolvedTable(kenArr);
            })
        }

        function createKen(num) {
            let kenArr = [];
            for(let i = 0; i < num; i++) {
                let rowArr = [];
                for(let j = 0; j < num; j++) {
                    rowArr.push(new Cell(i, j));
                }
                kenArr.push(rowArr);
            }
            return kenArr;
        }

        function fillKen(kenArr) {
            indexOfUnion = 0;
            arrOfUnions = [];
            console.log('I am fill Ken');
            const length = kenArr.length;
            for(let i = 1; i <= length; i++) {
                
                for(let j = 0; j < length; j++) {
                    let emptyCellInRow = kenArr[j].filter(function(cell) {
                        return !cell.fill;
                    })
                    let restCellForFill = emptyCellInRow.filter(function(el) {
                        let result = true;
                        for(let z = 0; z < j; z++) {
                            if(kenArr[z][el.col].num === i) result = false;
                        }
                        return result;
                    })
                   
                    if(!restCellForFill.length) {
                        for(let z = 0; z < j; z++) {
                            kenArr[z].forEach(el => {
                                if(el.num === i) {
                                    el.num = null;
                                    el.fill = false;
                                }
                            });
                        }

                        j = -1;
                        continue;
                    }   
                    
                    //console.log(j, restCellForFill);
                    let col = Math.round(Math.random() * (restCellForFill.length - 1));
                    let currentCell = restCellForFill[col];
                    currentCell.fillNum(i);
                    for(let i = 0; i < length; i++) {
                        let result = '';
                        for(let j = 0; j < length; j++){
                            let cur = kenArr[i][j].num ? kenArr[i][j].num : 0;
                            result += cur + " ";
                        }
                        //console.log(result); 
                    }
                    
                }

            }
        }

        function unionCells(arrOfCells) {
           let countUnionWithFour = 0;
           const maxCountUnionWithFour = (num - 4);
            for(let i = 0; i < arrOfCells.length; i++) {
                for(let j = 0; j < arrOfCells[i].length; j++) {
                    let x = i;
                    let y = j;
                    if(arrOfCells[x][y].union){
                        continue;
                    }
                    let countCell;

                    if(num == 4) {
                        countCell = Math.round(Math.random() * (3 - 2) + 2);
                       
                    } else {
                         
                        if(countUnionWithFour < maxCountUnionWithFour) {
                            countCell = Math.round(Math.random() * (4 - 2) + 2);
                            if(countCell === 4) countUnionWithFour++;
                        } else {
                            countCell = Math.round(Math.random() * (3 - 2) + 2);
                        }                         
                    }
                   
                    //console.log('count of union', countCell);
                    let currentUnion = new Union(indexOfUnion);
                    for(let z = 0; z < countCell; z++) {

                       if(z !== 0) {
                            let x1;
                            let y1;
                            let freeDirections = [1, 2, 3, 4];
                            let dir;
                            let att = 1;
                            do {
                                //let [x1, y1] = getNextCellcoordinates(x, y); что не так?
                                let arr = getNextCellcoordinates(x, y, freeDirections);
                                x1 = arr[0];
                                y1 = arr[1];
                                dir = arr[2];
                                //console.log('direction^ ', dir);
                                freeDirections = freeDirections.filter(el => {
                                    //console.log(el);
                                    return (el !== dir);
                                });


                                //console.log('attempt:', att , ', X: ',x, 'Y; ', y, 'X1: ',x1, 'Y1: ', y1, freeDirections);
                                //console.log(!isCellExistAndFree($table, x1, y1));
                                att++;
                            } while (!isCellExistAndFree(arrOfCells, x1, y1));
                             //destraction!!!!
                            x = x1;
                            y = y1;
                        }

                        //console.log(indexOfUnion);

                        arrOfCells[x][y].unionCells(indexOfUnion);
                        currentUnion.addCellToUnion(arrOfCells[x][y]);
                        

                        if(!isFreeNeighborCellExist(arrOfCells, x, y)) {
                           // console.log('break');
                            break;
                        }

                    }
                    arrOfUnions.push(currentUnion);
                    indexOfUnion++;
                }
            }
        }

        function getNextCellcoordinates(x, y, freeDirections) {
            let arrCoordinates = [];
            const index =  Math.round(Math.random() * (freeDirections.length - 1));
            const direction = freeDirections[index];
            switch (direction) {
                case 1 :
                    y++;
                    break;
                case 2 :
                    x++;
                    break;
                case 3 :
                    y--;
                    break;
                case 4 : 
                    x--;
                    break;
                default:
                    alert('упс!') //нужно ли здесь дефолт обязательно?
            }
            arrCoordinates[0] = x;
            arrCoordinates[1] = y;
            arrCoordinates[2] = direction;
            return arrCoordinates;
        }

        function drawBordersOfUnion(union) {
            const cells = union.cellsInUnion;
            
            let arrOfRowsNum = [];

            for(let i = 0; i < cells.length; i++) {
                if(arrOfRowsNum.indexOf(cells[i].row) === -1) {
                    arrOfRowsNum.push(cells[i].row);
                }
            }

            union.setSortRowsNumbers(arrOfRowsNum.sort());
            //console.log('arrrrr: ' , arrOfRowsNum);

            arrOfRowsNum.forEach(rowNum => {
                let currentRowCells = cells.filter(el => {
                    return el.row === rowNum;
                }).sort(compareCellsByCol);

                currentRowCells[currentRowCells.length-1].addBorder('right');
            })

            let arrOfColsNum = [];
            for(let i = 0; i < cells.length; i++) {
                if(arrOfColsNum.indexOf(cells[i].col) === -1) {
                    arrOfColsNum.push(cells[i].col);
                }
            }
           
            //console.log('arrrrr COL: ' , arrOfColsNum);

            arrOfColsNum.forEach(colNum => {
                let currentColCells = cells.filter(el => {
                    return el.col === colNum;
                }).sort(compareCellsByRow);

                currentColCells[currentColCells.length-1].addBorder('bottom');
            })

        }

       

        function setOperatorAndResult(union) {
            let operator = '';
            let result = 0;
            if(union.cellsInUnion.length === 1) {
                result = union.cellsInUnion[0].num;
            } else if(union.cellsInUnion.length === 2 ){ 
                if(divide(union.cellsInUnion[0].num, union.cellsInUnion[1].num) % 1 === 0) { 
                    if(union.cellsInUnion[0].num !== 1 && union.cellsInUnion[1].num !== 1) {
                        operator = String.fromCharCode(247);
                        result = divide(union.cellsInUnion[0].num, union.cellsInUnion[1].num);
                    } else {
                        operator = selectOperator(4);
                        result = getResultOfOperationInObject(union, operator);
                    }  
                }else {
                    operator = selectOperator(3);
                    result = getResultOfOperationInObject(union, operator);
                } 
            } else {
                operator = selectOperator(2);
                result = getResultOfOperationInObject(union, operator);     
            }
            union.setOperator(operator);
            union.setResult(result);
            union.setOperatorAndResult();
        }
   
        function selectOperator(num) {
            const operatorIndex = Math.round(Math.random() * (num - 1) + 1);
            let operator = '';
            switch(operatorIndex) {
                    case 1 :
                        operator = '+';
                        break;
                    case 2 :
                        operator = String.fromCharCode(215);
                        break;
                    case 3 :
                        operator = '-';
                        break;
                    case 4 :
                        operator = String.fromCharCode(247);
                        break;
                    default:
                        alert('упсcccc!')
                }
            return operator;
        }
        function getResultOfOperationInObject(union, operator) {
            let result = 0;
            
            switch(operator) {
                    case '+' :
                        result = union.cellsInUnion.reduce(function(acc, current){
                            return acc + current.num; 
                        }, 0);
                        break;
                    case String.fromCharCode(215) :
                        result = union.cellsInUnion.reduce(function(acc, current){
                            return acc * current.num; 
                        }, 1);
                        break;
                    case '-' :
                        result = Math.abs(union.cellsInUnion[0].num - union.cellsInUnion[1].num);
                        break;
                    case String.fromCharCode(247) :
                        result = divide(union.cellsInUnion[0].num, union.cellsInUnion[1].num);
                        break;
                    default:
                        alert('упсcccc!')
                }
            return result;
        }

        function getResultOfOperationInNode(union, operator) {
            let result = 0;
            
            switch(operator) {
                    case '+' :
                        result = union.reduce(function(acc, current){
                            return acc + +current.textContent; 
                        }, 0);
                        break;
                    case String.fromCharCode(215) :
                        result = union.reduce(function(acc, current){
                            return acc * current.textContent; 
                        }, 1);
                        break;
                    case '-' :
                        result = Math.abs(union[0].textContent - union[1].textContent);
                        break;
                    case String.fromCharCode(247) :
                        result = divide(union[0].textContent,union[1].textContent);
                        break;
                    default:
                        console.log('upssss')
                        alert('упсcccc!')
                }
            return result;
        }


        function divide(num1, num2) {
            const result = num1 > num2 ? num1 / num2 : num2 / num1;
            return result;
        }


       

        function selectCellinUnionForOperAttr(union) { 
            let cellsInTopRowSort = union.cellsInUnion.filter(cell => {
                return cell.row === union.sortRowsNums[0];
            }).sort(compareCellsByCol);
            cellsInTopRowSort[0].addOperatorAttr(union.oper_result);
        }
        
        function compareCellsByRow(cell1, cell2) {
            return cell1.row - cell2.row;

        }
        function compareCellsByCol(cell1, cell2) {
            return cell1.col - cell2.col;

        }


        function isCellExist(arrOfCells, x, y) {
            return (x >= 0 && x < arrOfCells.length) && (y >= 0 && y < arrOfCells.length);
        }
        function isCellFree(arrOfCells, x, y) {
            return !arrOfCells[x][y].union;
        }
        function isCellExistAndFree(arrOfCells, x, y) {
            return isCellExist(arrOfCells, x, y) && isCellFree(arrOfCells, x, y);
        }
        function isFreeNeighborCellExist(arrOfCells, x, y) {
            return isCellExistAndFree(arrOfCells, x + 1, y) || isCellExistAndFree(arrOfCells, x - 1, y) || isCellExistAndFree(arrOfCells, x, y + 1) || isCellExistAndFree(arrOfCells, x, y - 1);
        }

        function drawResolvedTable(arrObj) {
            const $table = document.querySelector('table');
            drawTable(arrObj, $table, true);
        }

        function drawTable(arrObj, $table, isresolved) {
            
            let tdInner = '';
            let inner = '';
            for(let i = 0; i < arrObj.length; i++) {
                let row = '<tr>';
                    for(let j = 0; j < arrObj[i].length; j++) {
                        const border = arrObj[i][j].border ? arrObj[i][j].border : '';
                        const attr_oper = arrObj[i][j].oper_resAttr ? `data-oper = ${arrObj[i][j].oper_resAttr}` : '';
                        const attr_union = `data-union = ${arrObj[i][j].unionIndex}`;
                            if(isresolved) {
                                tdInner = arrObj[i][j].num;
                            }
                            row += `<td class = 'cell ${border}' ${attr_oper} ${attr_union} tabindex = '1'>${tdInner}</td>`;
                    }
                row += '</tr>';    
                inner += row;
            }
            $table.innerHTML = inner;
        }

        function celebrateUserResolvedCorrect() {
            alert('Ура!!! Все правильно!');
        }
        
       

        

        function drawTableForResolve(arrObj) {
            const $table = document.querySelector('table');
            drawTable(arrObj, $table,  false);

            const $cells = $table.querySelectorAll('.cell');
            //console.log($cells);

            $cells.forEach(cell => {
                cell.addEventListener('click', event => {
                    event.target.focus();
                })
                cell.addEventListener('keydown', event => {
                    if(event.key >= 1 && event.key <= num) {
                        event.target.textContent = event.key;
                    }
                    
                    let keyCode = event.keyCode;
                    let row = event.target.parentElement.rowIndex;
                    let col = event.target.cellIndex;
                    const currentUnionIndex = event.target.dataset.union;
                    let currentUnion = arrOfUnions.find(un => {
                        return un.index === +currentUnionIndex;
                    })

                    //console.log(currentUnion);

                    if(keyCode === 46 || keyCode === 8) {
                        event.target.textContent = null;
                    }

                    const cellsInCurrentRowArray = Array.from($table.rows[row].cells);

                    const cellsInCurrentColArray = Array.from($cells).filter(el =>{
                        return el.cellIndex === col;
                    });

                    const cellsInCurrentUnion = Array.from($cells).filter(cell => {
                        return cell.dataset.union === currentUnionIndex;
                    })

                    //console.log(cellsInCurrentUnion);

                    cellsInCurrentRowArray.forEach(current => {
                        markCellInputIfRepeat($table, current);
                   });

                   cellsInCurrentColArray.forEach(current => {
                        markCellInputIfRepeat($table, current);
                   });

                   let resultUser = 0;
                   if(currentUnion.cellsInUnion.length === 1) {
                        resultUser = +event.target.textContent;
                   } else {
                        resultUser = getResultOfOperationInNode(cellsInCurrentUnion, currentUnion.oper);
                   }

                   //console.log(resultUser);
                   

                   const hasEmptyCell = cellsInCurrentUnion.findIndex(cell => {
                       return !cell.textContent;
                   }) === -1 ? false : true;
                 

                    if(!hasEmptyCell && resultUser !== currentUnion.result) {
                        
                        cellsInCurrentUnion.forEach(cell => {
                            cell.classList.add('wrongResult'); 
                        })
                    }else {
                        cellsInCurrentUnion.forEach(cell => {
                            if(cell.classList.contains('wrongResult')) {
                                cell.classList.remove('wrongResult');
                            }   
                        })
                    }


                    if(keyCode >= 37 && keyCode <= 40) {
                        switch(keyCode) {
                            case 37: 
                                if(col === 0) {
                                    col = col + num;
                                } 
                                setFocus($table, row, col - 1);
                                break;
                            case 38: 
                                if(row === 0) {
                                    row = row + num;
                                } 
                                setFocus($table, row - 1, col);
                                break;
                            case 39: 
                                if(col === num - 1) {
                                    col = col - num;
                                } 
                                setFocus($table, row, col + 1);
                                break;
                            case 40: 
                                if(row === num - 1) {
                                    row = row - num;
                                } 
                                setFocus($table, row + 1, col);
                                break;
                        }
                        
                    }

                    if(!Array.from($cells).find(node =>{
                        return !node.textContent
                    })) {
                        const isAnyMistake = Array.from($cells).find(node =>{
                        console.log('node', node.textContent, 'arrObj', arrObj[+node.parentElement.rowIndex][+node.cellIndex].num);

                        return +node.textContent !== arrObj[+node.parentElement.rowIndex][+node.cellIndex].num;
                    })
                        console.log(isAnyMistake);

                        if(!isAnyMistake) {
                            celebrateUserResolvedCorrect();
                        }
                    } 

                    
                }) 
            })               
                                   
                   
                                                        
                                    //console.log(getTargetNumOfCell(cell, arrObj), +el.target.value, el.target.classList.contains('red'));
                                    /*if(+el.target.value === getTargetNumOfCell(cell, arrObj) && el.target.classList.contains('red')) {
                                        el.target.classList.remove('red');
                                    } else if(+el.target.value !== getTargetNumOfCell(cell, arrObj)){
                                        el.target.classList.add('red');
                                    }    */
                    
               
           
        }

        function setFocus(table, row, col) {
            const cells = table.querySelectorAll('td');
            Array.from(cells).find(td => {              
                return (td.parentElement.rowIndex === row) && (td.cellIndex === col);
            }).focus();
        }

        function isNumberRepeatInLine(line, cell) {
            
            const isRepeat = line.filter(el => {
                return el !== cell;
            }).find(rest => {
                return cell.textContent && rest.textContent === cell.textContent;
            })
            return isRepeat;
        }

        function isNumberRepeatInRowOrCol(table, cell) {
            const cells = table.querySelectorAll('td');
            const cellsInCurrentRow = Array.from(table.rows[cell.parentElement.rowIndex].cells);
            const cellsInCurrentCol = Array.from(cells).filter(el =>{
                       return el.cellIndex === cell.cellIndex;
                   });

            return  isNumberRepeatInLine(cellsInCurrentRow, cell) || isNumberRepeatInLine(cellsInCurrentCol, cell);
        }
        
        function markCellInputIfRepeat(table, cell) {
            if(isNumberRepeatInRowOrCol(table, cell)) {
                cell.classList.add('red');
            } else {
                if(cell.classList.contains('red')){
                    cell.classList.remove('red');
                }
            }
        }

        function isAllNumbersCorrectInUnion($cell) {


        }

        function getTargetNumOfCell($cell, kenArr) {
           return kenArr[$cell.parentElement.rowIndex][$cell.cellIndex].num;  
        }

         /* let maxOfFour = 1;
        switch(num) {
            case 6 :
                maxOfFour = 2;
                break;
            case 7 :
                maxOfFour = 3;
                break;
            case 8 :
                maxOfFour = 3;
                break;
            case 9 : 
                maxOfFour = 4;
                break;
            default:
                alert('упсcccc!')
        }*/
        //row += `<td class = 'cell ${border}' ${attr}><input type="number" name="cell" class="cellInput" maxlength = "1" min = "1" max = "9"></td>`;  //${arrObj[i][j].num}
         /*function setOperatorAndResult(union) {
            let operatorAndResult = '';
            let result = 0;
            if(union.cellsInUnion.length === 1) {
                operatorAndResult = union.cellsInUnion[0].num;
            }else if(union.cellsInUnion.length === 2 ){ 
                if(divide(union.cellsInUnion[0].num, union.cellsInUnion[1].num) % 1 === 0 && (union.cellsInUnion[0].num !== 1 && union.cellsInUnion[1].num !== 1)){
                    //console.log(union.cellsInUnion[0], union.cellsInUnion[1], divide(union.cellsInUnion[0], union.cellsInUnion[1]) % 1);
                    operatorAndResult = divide(union.cellsInUnion[0].num, union.cellsInUnion[1].num) + String.fromCharCode(247);
                }else {
                    operatorAndResult = selectOperator(union, 3);
                } 
            } else {
                operatorAndResult = selectOperator(union, 2);     
            }
            union.setOperatorAndResult(operatorAndResult);
        }*/
        /* function selectOperator(union, num) {
            let result = 0;
            let operator = Math.round(Math.random() * (num - 1) + 1);
            switch(operator) {
                    case 1 :
                        operator = '+';
                        result = union.cellsInUnion.reduce(function(acc, current){
                            return acc + current.num; 
                        }, 0);
                        break;
                    case 2 :
                        operator = String.fromCharCode(215);
                        result = union.cellsInUnion.reduce(function(acc, current){
                            return acc * current.num; 
                        }, 1);
                        break;
                    case 3 :
                        operator = '-';
                        result = Math.abs(union.cellsInUnion[0].num - union.cellsInUnion[1].num);
                        break;
                    default:
                        alert('упсcccc!')
                }
            return result + operator;
        }*/
        
//const root = document.querySelector(':root');
                   //const rootStyles = getComputedStyle(root);
                   //let resultColor = rootStyles.getPropertyValue('--result-color');

                    //const styleElem = document.head.appendChild(document.createElement('style'));
                   // styleElem.innerHTML = `.cell[data-union = '${currentUnionIndex}']::after {color: red;}`
       
    </script>

    
</body>
</html>